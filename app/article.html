<!DOCTYPE html>
<html>
<head>
	<title>个人博客</title>
	<!-- <meta http-equiv="Content-Type" content="text/html; charset=utf-8" /> -->
	<meta charset="UTF-8"/>
	<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
	<link href="../images/05.png" rel="shortcut icon">
	<meta name="description" content="阅读，实践，学习，积累，分享" />
	<meta name="viewport" content="initial-scale=1,maximum-scale=1, minimum-scale=1">
	<link rel="stylesheet" href="../bootstrap/css/bootstrap.min.css">
	<script type="text/javascript" src="../jquery.min.js"></script>
	<script type="text/javascript" src="../bootstrap/js/bootstrap.min.js"></script>
</head>
<style type="text/css">
.top { position: absolute; top: 0; left: 0; right: 0; height: 60px; background: lightblue; }
#left { position: absolute; left: 0; top: 60px; bottom: 0; width: 200px; background: lightblue; overflow-y: auto; }
#right { position: absolute; left: 200px; top: 60px; bottom: 0; right: 0; background: #fff; overflow-y: auto; overflow-x: hidden; }
.inner { min-height: 1000px; width: 95%; margin: 0 auto; }
#header { margin: 0 auto; width: 100%; height: 60px; background: lightblue; line-height: 60px; font-size: 22px; color: green; }
#right img { max-width: 90%; }
#header img { margin: 5px; width: 50px; height: 50px; }
#header .welcome { float: right; margin-right: 30px; font-size: 12px; }
.name-info { float: left; }
.nav-link { display: inline-block; list-style: none; padding-left: 0; }
.nav-link a { text-decoration: none; color: green; opacity: 1; }
.nav-link a:hover { opacity: 0.6; border-bottom: 2px solid green; height: 50px; }
.nav-link li { list-style: none; float: left; margin-left: 80px; }
.active-nav { border-bottom: 2px solid green; height: 50px; opacity: 0.6; }
</style>
<body >
	<div class="parent-container">
		<div class="top">
			<div id="header">
			  <div class="name-info">
			    <img src="../images/05.png">
			    <span class="name">李景超的博客</span>  
			  </div>
			  <ul class="nav-link">
			    <li><a href="/">首页</a></li>
			    <li><a href="/app">JS</a></li>
			    <li><a href="/app/article" class="active-nav">随笔</a></li>
			  </ul>
			  <span class="welcome">欢迎进入我的博客！&nbsp&nbsp<span class="time"></span></span>
			</div>
		</div>
		<div id="left">
			<ul class="nav nav-tabs">              
		      <li><a href="#cnt1">H5缓存机制解析和实战</a></li>
		      <li><a href="#cnt2">web前端大致规范要求</a></li>
		      <li><a href="#cnt3">JavaScript异步编程</a></li>
		      <li><a href="#cnt4">H5</a></li>
		      <li><a href="#cnt5">web</a></li>
		      <li><a href="#cnt6">JavaScript</a></li>
		    </ul>

		    <ul><a class="back-to-top" href="#cnt1">返回顶部</a></ul>
		</div>
		<div id="right" data-spy='scroll' data-target='#left'>
			<div class="inner">
				<div id="cnt1">
					<h2 class="title">H5缓存机制解析</h2>
					<div id="page-content" class="rich_media_area_primary">           
		                <div class="rich_media_content " id="js_content">   
		                    <blockquote style="margin: 1.2em 0px;border-left: 4px solid rgb(221, 221, 221); padding: 0px 1em; color: rgb(119, 119, 119); quotes: none;"></blockquote><h2 style="margin: 1.3em 0px 1em; padding: 0px; font-weight: bold;font-size: 1.4em; border-bottom: 1px solid rgb(238, 238, 238);">导语</h2><p>web缓存是web开发逃不开的一个话题，在减少网络带宽消耗、降低服务器压力和提高页面打开速度方面有广泛应用。本文从实际web应用项目中缓存相关问题出发，较为全面地分析了html5缓存机制的原理与应用以及移动端应用webView对html5缓存机制的支持方式，以供web开发的同学们参考。</p><h2 style="margin-top: 1.3em; margin-bottom: 1em; font-weight: bold; font-size: 1.4em; white-space: normal; border-bottom: 1px solid rgb(238, 238, 238);">正文</h2><p style="margin: 0px 0px 1.2em !important;">在web项目开发中，我们可能都曾碰到过这样一个棘手的问题：</p><p style="margin: 0px 0px 1.2em !important;"><strong>线上项目需要更新一个有问题的资源（可能是图片，js，css,json数据等）,这个资源已经发布了很长一段时间，为什么页面在浏览器里打开还是没有看到更新？</strong></p><p style="margin: 0px 0px 1.2em !important;">有些web开发经验的同学应该马上会想到，可能是资源发布出了岔子导致没有实际发布成功，更大的可能是老的资源被缓存了。说到web缓存，首先我们要弄清它是什么。Web缓存可以理解为Web资源在Web服务器和客户端（浏览器）的副本，其作用体现在减少网络带宽消耗、降低服务器压力和减少网络延迟，加快页面打开速度等方面(笔者在香港求学期间看到港台地区将cache译为“快取”，除了读音相近，大概就是贴近这层含义)。他们通常还会告诉你：ctrl+F5强刷一下，但是<strong>本文下面的内容将会说明为什么强制刷新在去除缓存上不总是能奏效的</strong>，更何况对于线上项目而言，总不能让所有已经访问过的用户撸起袖子岔开两个手指都强制刷新一下吧？</p><p style="margin: 0px 0px 1.2em !important;">同时，当前原生 + html5的混合模式移动应用(hybrid APP)因可大幅降低移动应用的开发成本，并且可在用户桌面形成独立入口以及有接近原生应用的体验而大行其道，APP内嵌h5应用的开发也是本人现在工作内容重要的一部分，<strong>本文将从实际项目开发中遇到的问题出发，一窥html5和app内webview的缓存机制真容。</strong></p><h2 style="margin: 1.3em 0px 1em; padding: 0px; font-weight: bold;font-size: 1.4em; border-bottom: 1px solid rgb(238, 238, 238);">一、协议缓存</h2><p style="margin: 0px 0px 1.2em !important;">回到开头的那个问题，更新了一张图片，发布之后反复重新进页面总是看不到更新，这是为什么呢？</p><p style="margin: 0px 0px 1.2em !important;">这里我们假设已经排除了资源没有发布成功过的情况，那么第一步，我们可能会认为是http协议缓存（也称为浏览器缓存或者网页缓存）。</p><p style="margin: 0px 0px 1.2em !important;">http协议缓存机制是指通过 HTTP 协议头里的 Cache-Control（或 Expires）和 Last-Modified（或 Etag）等字段来控制文件缓存的机制。</p><ul style="margin: 1.2em 0px;padding-left: 2em;" class="list-paddingleft-2"><li><p style="margin: 0px 0px 1.2em !important;margin: 0.5em 0px !important;"><strong>Cache-Control</strong> 用于控制文件在本地缓存有效时长。最常见的，比如服务器回包：Cache-Control:max-age=600 表示文件在本地应该缓存，且有效时长是600秒（从发出请求算起）。在接下来600秒内，如果有请求这个资源，浏览器不会发出 HTTP 请求，而是直接使用本地缓存的文件。</p></li><li><p style="margin: 0px 0px 1.2em !important;margin: 0.5em 0px !important;"><strong>Last-Modified</strong> 是标识文件在服务器上的最新更新时间。下次请求时，如果文件缓存过期，浏览器通过 If-Modified-Since 字段带上这个时间，发送给服务器，由服务器比较时间戳来判断文件是否有修改。如果没有修改，服务器返回304告诉浏览器继续使用缓存；如果有修改，则返回200，同时返回最新的文件。</p></li></ul><p style="margin: 0px 0px 1.2em !important;">Cache-Control 通常与 Last-Modified 一起使用。一个用于控制缓存有效时间，一个在缓存失效后，向服务查询是否有更新。</p><p style="margin: 0px 0px 1.2em !important;">Cache-Control 还有一个同功能的字段：Expires。Expires 的值一个绝对的时间点，如：Expires: Thu, 10 Nov 2015 08:45:11 GMT，表示在这个时间点之前，缓存都是有效的。</p><p style="margin: 0px 0px 1.2em !important;">Expires 是 HTTP1.0 标准中的字段，Cache-Control 是 HTTP1.1 标准中新加的字段，功能一样，都是控制缓存的有效时间。当这两个字段同时出现时，Cache-Control 是高优化级的。</p><p style="margin: 0px 0px 1.2em !important;">Etag 也是和 Last-Modified 一样，对文件进行标识的字段。不同的是，Etag 的取值是一个对文件进行标识的特征字串。在向服务器查询文件是否有更新时，浏览器通过 If-None-Match 字段把特征字串发送给服务器，由服务器和文件最新特征字串进行匹配，来判断文件是否有更新。没有更新回包304，有更新回包200。Etag 和 Last-Modified 可根据需求使用一个或两个同时使用。两个同时使用时，只要满足基中一个条件，就认为文件没有更新。</p><p style="margin: 0px 0px 1.2em !important;"><strong>一个比较形象的理解：</strong></p><blockquote style="margin: 1.2em 0px;border-left: 4px solid rgb(221, 221, 221); padding: 0px 1em; color: rgb(119, 119, 119); quotes: none;"><p style="margin: 0px 0px 1.2em !important;">翠花：狗蛋，你几岁了？<br>狗蛋：我18岁了。(200)<br>翠花记住了狗蛋18岁(200 from cache)</p></blockquote><p style="margin: 0px 0px 1.2em !important;">=================================</p><blockquote style="margin: 1.2em 0px;border-left: 4px solid rgb(221, 221, 221); padding: 0px 1em; color: rgb(119, 119, 119); quotes: none;"><p style="margin: 0px 0px 1.2em !important;">翠花：狗蛋 ，你几岁了？我猜你18岁。<br>狗蛋：靠，知道还问我!（304）</p></blockquote><p style="margin: 0px 0px 1.2em !important;">=================================</p><blockquote style="margin: 1.2em 0px;border-left: 4px solid rgb(221, 221, 221); padding: 0px 1em; color: rgb(119, 119, 119); quotes: none;"><p style="margin: 0px 0px 1.2em !important;">翠花：狗蛋 ，你几岁了？我猜你18岁。<br>狗蛋：翠花 ，我已经19岁了。（200）</p></blockquote><p style="margin: 0px 0px 1.2em !important;"><strong>不过有两种情况比较特殊：</strong></p><ol style="margin: 1.2em 0px;padding-left: 2em;" class="list-paddingleft-2"><li><p style="margin: 0px 0px 1.2em !important;margin: 0.5em 0px !important;"><strong>手动刷新页面</strong>（F5)，浏览器会直接认为缓存已经过期（可能缓存还没有过期），在请求中加上字段：Cache-Control:max-age=0，发包向服务器查询是否有文件是否有更新。</p></li><li><p style="margin: 0px 0px 1.2em !important;margin: 0.5em 0px !important;"><strong>强制刷新页面</strong>（Ctrl+F5)，浏览器会直接忽略本地的缓存（有缓存也会认为本地没有缓存），在请求中加上字段：Cache-Control:no-cache（或 Pragma:no-cache），发包向服务重新拉取文件。</p></li></ol><p style="margin: 0px 0px 1.2em !important;">当然，各个浏览器对于刷新和强制刷新的实现方式也有一些区别。</p><p style="margin: 0px 0px 1.2em !important;"><strong>那么，如果线上更新了web资源，如何能让尽快更新呢？（要知道像图片这样比较少更新的资源一般缓存时间都设置得比较长，比如game.gtimg.cn域名下是一天，有问题的图片在用户侧缓存这么长时间是不可接受的）</strong></p><p style="margin: 0px 0px 1.2em !important;"><strong>方法一 修改请求header头，比如php添加：</strong></p><pre style="font-size: 0.85em; font-family: Consolas, Inconsolata, Courier, monospace;font-size: 1em; line-height: 1.2em;margin: 1.2em 0px;"><code class="" style="font-size: 0.85em; font-family: Consolas, Inconsolata, Courier, monospace; margin: 0px 0.15em; white-space: pre; overflow: auto; border-radius: 3px; border-width: 1px; border-style: solid; border-color: rgb(204, 204, 204); padding: 0.5em; background: rgb(35, 36, 31); text-size-adjust: none; color: rgb(248, 248, 242); display: block !important;">header(<span class="" style="color: rgb(230, 219, 116);">"Expires: Mon, 26 Jul 1997 05:00:00 GMT"</span>);
						header(<span class="" style="color: rgb(230, 219, 116);">"Cache-Control: no-cache, must-revalidate"</span>);
						header(<span class="" style="color: rgb(230, 219, 116);">"Pragma: no-cache"</span>);</code></pre><p style="margin: 0px 0px 1.2em !important;"><strong>方法二 修改html的head块：</strong></p><pre style="font-size: 0.85em; font-family: Consolas, Inconsolata, Courier, monospace;font-size: 1em; line-height: 1.2em;margin: 1.2em 0px;"><code class="" style="font-size: 0.85em; font-family: Consolas, Inconsolata, Courier, monospace; margin: 0px 0.15em; white-space: pre; overflow: auto; border-radius: 3px; border-width: 1px; border-style: solid; border-color: rgb(204, 204, 204); padding: 0.5em; background: rgb(35, 36, 31); text-size-adjust: none; color: rgb(248, 248, 242); display: block !important;"><span class="" style="color: rgb(248, 248, 242);">&lt;<span class="" style="color: rgb(166, 226, 46);color: rgb(249, 38, 114);">META</span> <span class="" style="color: rgb(249, 38, 114);">HTTP-EQUIV</span>=<span class="" style="color: rgb(166, 226, 46);color: rgb(249, 38, 114);">"pragma"</span> <span class="" style="color: rgb(249, 38, 114);">CONTENT</span>=<span class="" style="color: rgb(166, 226, 46);color: rgb(249, 38, 114);">"no-cache"</span>&gt;<br></span><span class="" style="color: rgb(248, 248, 242);">&lt;<span class="" style="color: rgb(166, 226, 46);color: rgb(249, 38, 114);">META</span> <span class="" style="color: rgb(249, 38, 114);">HTTP-EQUIV</span>=<span class="" style="color: rgb(166, 226, 46);color: rgb(249, 38, 114);">"Cache-Control"</span> <span class="" style="color: rgb(249, 38, 114);">CONTENT</span>=<span class="" style="color: rgb(166, 226, 46);color: rgb(249, 38, 114);">"no-cache, must-revalidate"</span>&gt;<br></span><span class="" style="color: rgb(248, 248, 242);">&lt;<span class="" style="color: rgb(166, 226, 46);color: rgb(249, 38, 114);">META</span> <span class="" style="color: rgb(249, 38, 114);">HTTP-EQUIV</span>=<span class="" style="color: rgb(166, 226, 46);color: rgb(249, 38, 114);">"expires"</span> <span class="" style="color: rgb(249, 38, 114);">CONTENT</span>=<span class="" style="color: rgb(166, 226, 46);color: rgb(249, 38, 114);">"Wed, 26 Feb 1997 08:21:57 GMT"</span>&gt;<br></span><span class="" style="color: rgb(248, 248, 242);">&lt;<span class="" style="color: rgb(166, 226, 46);color: rgb(249, 38, 114);">META</span> <span class="" style="color: rgb(249, 38, 114);">HTTP-EQUIV</span>=<span class="" style="color: rgb(166, 226, 46);color: rgb(249, 38, 114);">"expires"</span> <span class="" style="color: rgb(249, 38, 114);">CONTENT</span>=<span class="" style="color: rgb(166, 226, 46);color: rgb(249, 38, 114);">"0"</span>&gt;</span></code></pre><p style="margin: 0px 0px 1.2em !important;"><strong>方法三：添加随机参数：</strong></p><p style="margin: 0px 0px 1.2em !important;">对于图片或者css，可使用如下方式：</p><pre style="font-size: 0.85em; font-family: Consolas, Inconsolata, Courier, monospace;font-size: 1em; line-height: 1.2em;margin: 1.2em 0px;"><code class="" style="font-size: 0.85em; font-family: Consolas, Inconsolata, Courier, monospace; margin: 0px 0.15em; white-space: pre; overflow: auto; border-radius: 3px; border-width: 1px; border-style: solid; border-color: rgb(204, 204, 204); padding: 0.5em; background: rgb(35, 36, 31); text-size-adjust: none; color: rgb(248, 248, 242); display: block !important;">&lt;img src="./data/avatar_mingpian_bak.jpg?rand=h9xqeI" &nbsp;width="156" height="98"&gt;</code></pre><p style="margin: 0px 0px 1.2em !important;">对于js则可以直接使用时间戳：</p><pre style="font-size: 0.85em; font-family: Consolas, Inconsolata, Courier, monospace;font-size: 1em; line-height: 1.2em;margin: 1.2em 0px;"><code class="" style="font-size: 0.85em; font-family: Consolas, Inconsolata, Courier, monospace; margin: 0px 0.15em; white-space: pre; overflow: auto; border-radius: 3px; border-width: 1px; border-style: solid; border-color: rgb(204, 204, 204); padding: 0.5em; background: rgb(35, 36, 31); text-size-adjust: none; color: rgb(248, 248, 242); display: block !important;">&lt;script language=<span class="" style="color: rgb(230, 219, 116);">"javascript"</span> src=<span class="" style="color: rgb(230, 219, 116);">"UILib/Common/Common.js?time=new Date()"</span>&gt;</code></pre><h2 style="margin: 1.3em 0px 1em; padding: 0px; font-weight: bold;font-size: 1.4em; border-bottom: 1px solid rgb(238, 238, 238);">二、应用缓存</h2><p style="margin: 0px 0px 1.2em !important;">除了http协议缓存，HTML5 提供一种应用程序缓存机制，使得基于web的应用程序可以离线运行。为了能够让用户在离线状态下继续访问 Web 应用，开发者需要提供一个 cache manifest 文件。这个文件中列出了所有需要在离线状态下使用的资源，浏览器会把这些资源缓存到本地。例如以下页面：</p><pre style="font-size: 0.85em; font-family: Consolas, Inconsolata, Courier, monospace;font-size: 1em; line-height: 1.2em;margin: 1.2em 0px;"><code class="" style="font-size: 0.85em; font-family: Consolas, Inconsolata, Courier, monospace; margin: 0px 0.15em; white-space: pre; overflow: auto; border-radius: 3px; border-width: 1px; border-style: solid; border-color: rgb(204, 204, 204); padding: 0.5em; background: rgb(35, 36, 31); text-size-adjust: none; color: rgb(248, 248, 242); display: block !important;"><span class="" style="color: rgb(117, 113, 94);">&lt;!-- calender.html --&gt;<br></span><span class="" style="color: rgb(117, 113, 94);">&lt;!DOCTYPE HTML&gt;<br></span><span class="" style="color: rgb(248, 248, 242);">&lt;<span class="" style="color: rgb(166, 226, 46);color: rgb(249, 38, 114);">html</span> <span class="" style="color: rgb(249, 38, 114);">manifest</span>=<span class="" style="color: rgb(166, 226, 46);color: rgb(249, 38, 114);">"calender.manifest"</span>&gt;<br></span><span class="" style="color: rgb(248, 248, 242);">&lt;<span class="" style="color: rgb(166, 226, 46);color: rgb(249, 38, 114);">head</span>&gt;</span>
						 &nbsp; <span class="" style="color: rgb(248, 248, 242);">&lt;<span class="" style="color: rgb(166, 226, 46);color: rgb(249, 38, 114);">title</span>&gt;</span>calender<span class="" style="color: rgb(248, 248, 242);">&lt;/<span class="" style="color: rgb(166, 226, 46);color: rgb(249, 38, 114);">title</span>&gt;</span>
						 &nbsp; <span class="" style="color: rgb(248, 248, 242);">&lt;<span class="" style="color: rgb(166, 226, 46);color: rgb(249, 38, 114);">script</span> <span class="" style="color: rgb(249, 38, 114);">src</span>=<span class="" style="color: rgb(166, 226, 46);color: rgb(249, 38, 114);">"calender.js"</span>&gt;</span><span class=""></span><span class="" style="color: rgb(248, 248, 242);">&lt;/<span class="" style="color: rgb(166, 226, 46);color: rgb(249, 38, 114);">script</span>&gt;</span>
						 &nbsp; <span class="" style="color: rgb(248, 248, 242);">&lt;<span class="" style="color: rgb(166, 226, 46);color: rgb(249, 38, 114);">link</span> <span class="" style="color: rgb(249, 38, 114);">rel</span>=<span class="" style="color: rgb(166, 226, 46);color: rgb(249, 38, 114);">"stylesheet"</span> <span class="" style="color: rgb(249, 38, 114);">href</span>=<span class="" style="color: rgb(166, 226, 46);color: rgb(249, 38, 114);">"calender.css"</span>&gt;<br></span><span class="" style="color: rgb(248, 248, 242);">&lt;/<span class="" style="color: rgb(166, 226, 46);color: rgb(249, 38, 114);">head</span>&gt;<br></span><span class="" style="color: rgb(248, 248, 242);">&lt;<span class="" style="color: rgb(166, 226, 46);color: rgb(249, 38, 114);">body</span>&gt;</span>
						 &nbsp; <span class="" style="color: rgb(248, 248, 242);">&lt;<span class="" style="color: rgb(166, 226, 46);color: rgb(249, 38, 114);">p</span>&gt;</span>The time is: <span class="" style="color: rgb(248, 248, 242);">&lt;<span class="" style="color: rgb(166, 226, 46);color: rgb(249, 38, 114);">output</span> <span class="" style="color: rgb(249, 38, 114);">id</span>=<span class="" style="color: rgb(166, 226, 46);color: rgb(249, 38, 114);">"calender"</span>&gt;</span><span class="" style="color: rgb(248, 248, 242);">&lt;/<span class="" style="color: rgb(166, 226, 46);color: rgb(249, 38, 114);">output</span>&gt;</span><span class="" style="color: rgb(248, 248, 242);">&lt;/<span class="" style="color: rgb(166, 226, 46);color: rgb(249, 38, 114);">p</span>&gt;<br></span><span class="" style="color: rgb(248, 248, 242);">&lt;/<span class="" style="color: rgb(166, 226, 46);color: rgb(249, 38, 114);">body</span>&gt;<br></span><span class="" style="color: rgb(248, 248, 242);">&lt;/<span class="" style="color: rgb(166, 226, 46);color: rgb(249, 38, 114);">html</span>&gt;</span></code></pre><p style="margin: 0px 0px 1.2em !important;">其对应的 calender.manifest代码</p><pre style="font-size: 0.85em; font-family: Consolas, Inconsolata, Courier, monospace;font-size: 1em; line-height: 1.2em;margin: 1.2em 0px;"><code class="" style="font-size: 0.85em; font-family: Consolas, Inconsolata, Courier, monospace; margin: 0px 0.15em; white-space: pre; overflow: auto; border-radius: 3px; border-width: 1px; border-style: solid; border-color: rgb(204, 204, 204); padding: 0.5em; background: rgb(35, 36, 31); text-size-adjust: none; color: rgb(248, 248, 242); display: block !important;">CACHE MANIFEST
						calender.html
						calender.css
						calender.js</code></pre><p style="margin: 0px 0px 1.2em !important;"><strong>cache manifest 格式遵循以下原则：</strong></p><ol style="margin: 1.2em 0px;padding-left: 2em;" class="list-paddingleft-2"><li><p>首行必须是 CACHE MANIFEST。</p></li><li><p>其后，每一行列出一个需要缓存的资源文件名。</p></li><li><p>可根据需要列出在线访问的白名单。白名单中的所有资源不会被缓存，在使用时将直接在线访问。声明白名单使用 NETWORK：标识符。</p></li><li><p>如果在白名单后还要补充需要缓存的资源，可以使用 CACHE：标识符。</p></li><li><p>如果要声明某 URI 不能访问时的替补 URI，可以使用 FALLBACK：标识符。其后的每一行包含两个 URI，当第一个 URI 不可访问时，浏览器将尝试使用第二个 URI。</p></li><li><p>注释要另起一行，以 # 号开头。</p></li></ol><p style="margin: 0px 0px 1.2em !important;">例如以下manifest文件：</p><pre style="font-size: 0.85em; font-family: Consolas, Inconsolata, Courier, monospace;font-size: 1em; line-height: 1.2em;margin: 1.2em 0px;"><code class="" style="font-size: 0.85em; font-family: Consolas, Inconsolata, Courier, monospace; margin: 0px 0.15em; white-space: pre; overflow: auto; border-radius: 3px; border-width: 1px; border-style: solid; border-color: rgb(204, 204, 204); padding: 0.5em; background: rgb(35, 36, 31); text-size-adjust: none; color: rgb(248, 248, 242); display: block !important;">CACHE MANIFEST
						# 上一行是必须书写
						images/sound-icon.png
						images/background.png
						NETWORK:
						comm.cgi
						# 下面是另一些需要缓存的资源，在这个示例中只有一个 css 文件。
						CACHE:
						style/default.css
						FALLBACK:
						/files/projects /projects</code></pre><p style="margin: 0px 0px 1.2em !important;"><strong>那么，如果使用了应用缓存，应该如何去更新呢？有以下两种方式</strong></p><h4 style="margin: 1.3em 0px 1em; padding: 0px; font-weight: bold;font-size: 1.2em;">1、自动更新</h4><p style="margin: 0px 0px 1.2em !important;">浏览器除了在第一次访问 Web 应用时缓存资源外，只会在 cache manifest 文件本身发生变化时更新缓存。而 cache manifest 中的资源文件发生变化并不会触发更新。</p><h4 style="margin: 1.3em 0px 1em; padding: 0px; font-weight: bold;font-size: 1.2em;">2、手动更新</h4><p style="margin: 0px 0px 1.2em !important;">开发者也可以使用 window.applicationCache 的接口更新缓存。方法是检测 window.applicationCache.status 的值，如果是 UPDATEREADY，那么可以调用 window.applicationCache.update() 更新缓存。示范代码如下。</p><p style="margin: 0px 0px 1.2em !important;">手动更新缓存代码：</p><pre style="font-size: 0.85em; font-family: Consolas, Inconsolata, Courier, monospace;font-size: 1em; line-height: 1.2em;margin: 1.2em 0px;"><code class="" style="font-size: 0.85em; font-family: Consolas, Inconsolata, Courier, monospace; margin: 0px 0.15em; white-space: pre; overflow: auto; border-radius: 3px; border-width: 1px; border-style: solid; border-color: rgb(204, 204, 204); padding: 0.5em; background: rgb(35, 36, 31); text-size-adjust: none; color: rgb(248, 248, 242); display: block !important;"><span class="" style="color: rgb(249, 38, 114);">if</span>(<span class="" style="color: rgb(230, 219, 116);">window</span>.applicationCache.status== <span class="" style="color: rgb(230, 219, 116);">window</span>.applicationCache.UPDATEREADY)
						{<br><span class="" style="color: rgb(230, 219, 116);"> &nbsp; &nbsp;window</span>.applicationCache.update();
						}</code></pre><p style="margin: 0px 0px 1.2em !important;"><strong>然而，有时候虽然应用缓存刷新了，但是还是不能看到最新的：那么有可能是使用了本地存储。</strong>常用的本地存储有DOM Storage和webSQL和indexDB三种</p><p style="margin: 0px 0px 1.2em !important;">，细节可以搜索这篇文章 <span style="color: rgb(0, 128, 255);">《HTML5 Storage Wars - localStorage vs. IndexedDB vs. Web SQL》</span>，这里就不展开了，<strong>需要注意的是，若使用本地存储，想要清理缓存，除了清理本地存储文件外，还需要重启APP，以消除内存中的备份。</strong></p><h2 style="margin: 1.3em 0px 1em; padding: 0px; font-weight: bold;font-size: 1.4em; border-bottom: 1px solid rgb(238, 238, 238);">三、移动端APP如何支持html5缓存机制？</h2><p style="margin: 0px 0px 1.2em !important;">笔者现在常会和移动端APP内嵌html5页面打交道，那么移动端hybrid方式开发的APP，如何支持以上的缓存方式呢？</p><p style="margin: 0px 0px 1.2em !important;">需要了解这些，我们先了解下hybrid方式开发的APP怎么展示网页。简单得说就是使用了webView，那么什么是webView呢？WebView是手机中内置了一款高性能webkit 内核浏览器,在SDK 中封装的一个组件。 没有提供地址栏和导航栏，WebView只是单纯的展示一个网页界面。简单地可以理解为简略版的浏览器。</p><h3 style="margin: 1.3em 0px 1em; padding: 0px; font-weight: bold;font-size: 1.3em;">安卓端：</h3><h4 style="margin: 1.3em 0px 1em; padding: 0px; font-weight: bold;font-size: 1.2em;">1、网页缓存：</h4><p style="margin: 0px 0px 1.2em !important;">在data/应用package下生成database与cache两个文件夹，请求的Url记录是保存在webviewCache.db里，而url的内容是保存在webviewCache文件夹下。</p><p style="margin: 0px 0px 1.2em !important;"><strong>&lt;1&gt; 缓存构成</strong></p><pre style="font-size: 0.85em; font-family: Consolas, Inconsolata, Courier, monospace;font-size: 1em; line-height: 1.2em;margin: 1.2em 0px;"><code style="font-size: 0.85em; font-family: Consolas, Inconsolata, Courier, monospace; margin: 0px 0.15em; background-color: rgb(248, 248, 248); white-space: pre; overflow: auto; border-radius: 3px; border-width: 1px; border-style: solid; border-color: rgb(204, 204, 204); padding: 0.5em 0.7em; display: block !important;">/data/data/package_name/cache/
						/data/data/package_name/database/webview.db
						/data/data/package_name/database/webviewCache.db</code></pre><p style="margin: 0px 0px 1.2em !important;"><strong>&lt;2&gt; 缓存模式</strong></p><ul style="margin: 1.2em 0px;padding-left: 2em;" class="list-paddingleft-2"><li><p><strong>LOAD_CACHE_ONLY</strong>： 不使用网络，只读取本地缓存数据，</p></li><li><p><strong>LOAD_DEFAULT</strong>：根据cache-control决定是否从网络上取数据，</p></li><li><p><strong>LOAD_CACHE_NORMAL</strong>：API level 17中已经废弃, 从API level 11开始作用同- - LOAD_DEFAULT模式，</p></li><li><p><strong>LOAD_NO_CACHE</strong>: 不使用缓存，只从网络获取数据，</p></li><li><p><strong>LOAD_CACHE_ELSE_NETWORK</strong>，只要本地有，无论是否过期，或者no-cache，都使用缓存中的数据。</p></li></ul><p style="margin: 0px 0px 1.2em !important;">如果一个页面的cache-control为no-cache，在模式LOAD_DEFAULT下，无论如何都会从网络上取数据，如果没有网络，就会出现错误页面；在LOAD_CACHE_ELSE_NETWORK模式下，无论是否有网络，只要本地有缓存，都使用缓存。本地没有缓存时才从网络上获取。如果一个页面的cache-control为max-age=60，在两种模式下都使用本地缓存数据。</p><h4 style="margin: 1.3em 0px 1em; padding: 0px; font-weight: bold;font-size: 1.2em;">2、应用缓存</h4><p style="margin: 0px 0px 1.2em !important;">根据setAppCachePath(String appCachePath)提供的路径，在H5使用缓存过程中生成的缓存文件。</p><p style="margin: 0px 0px 1.2em !important;">无模式选择，通过setAppCacheEnabled(boolean flag)设置是否打开。默认关闭，即，H5的缓存无法使用。如果要手动清理缓存，需要找到调用setAppCachePath(String appCachePath)设置缓存的路径，把它下面的文件全部删除就OK了。</p><h3 style="margin: 1.3em 0px 1em; padding: 0px; font-weight: bold;font-size: 1.3em;">iOS端：</h3><p style="margin: 0px 0px 1.2em !important;">iOS的UIWebView组件不支持html5应用程序缓存的方式，对于协议缓存，可以使用sdk中的NSURLCache类。NSURLRequest需要一个缓存参数来说明它请求的url何如缓存数据的，我们先看下它的CachePolicy类型。</p><ol style="margin: 1.2em 0px;padding-left: 2em;" class="list-paddingleft-2"><li><p>NSURLRequestUseProtocolCachePolicy NSURLRequest 默认的cache policy，使用Protocol协议定义，注意这种情况下默认缓存时间是60s</p></li><li><p>NSURLRequestReloadIgnoringCacheData 忽略缓存直接从原始地址下载。</p></li><li><p>NSURLRequestReturnCacheDataElseLoad 只有在cache中不存在data时才从原始地址下载。</p></li><li><p>NSURLRequestReturnCacheDataDontLoad 只使用cache数据，如果不存在cache，请求失败；用于没有建立网络连接离线模式；</p></li><li><p>NSURLRequestReloadIgnoringLocalAndRemoteCacheData：忽略本地和远程的缓存数据，直接从原始地址下载，与NSURLRequestReloadIgnoringCacheData类似。</p></li><li><p>NSURLRequestReloadRevalidatingCacheData:验证本地数据与远程数据是否相同，如果不同则下载远程数据，否则使用本地数据。</p></li></ol><p style="margin: 0px 0px 1.2em !important;">处于数据安全性的考虑，iOS的应用拥有自己独立的目录，用来写入应用的数据或者首选项参数。应用安装后，会有对应的home目录，基于NSURLCache来实现数据的Cache，NSURLCache会存放在home内的子目录Library/ Caches下，以Bundle Identifier为文件夹名建立Cache的存放路径。在xcode下可以管理对应的文件，具体可以搜索阅读此文：<span style="color: rgb(0, 128, 255);">《关于 iOS 删除缓存的那些事儿》</span></p><p><img data-s="300,640" data-type="png" data-src="http://mmbiz.qpic.cn/mmbiz_png/tnZGrhTk4dfWKseqPuud1kuhicLwg6rlLfe3LT69icfHNjN6pIL1swmJfV6ogO9kVibib3DWn8Cb7s3Wl5ea0cic0iaw/0?wx_fmt=png" data-ratio="1.047713717693837" data-w="503" class=" " src="http://mmbiz.qpic.cn/mmbiz_png/tnZGrhTk4dfWKseqPuud1kuhicLwg6rlLfe3LT69icfHNjN6pIL1swmJfV6ogO9kVibib3DWn8Cb7s3Wl5ea0cic0iaw/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1" style="width: auto !important; height: auto !important; visibility: visible !important;" data-fail="0"></p><h2 style="margin: 1.3em 0px 1em; padding: 0px; font-weight: bold;font-size: 1.4em; border-bottom: 1px solid rgb(238, 238, 238);">四、总结</h2><p style="margin: 0px 0px 1.2em !important;">综上所述，html5缓存主要可以分为http协议缓存、应用缓存、DOM Storage、webSQL和indexedDB几种方式，针对不同的方式清理缓存的方式也不尽相同，上文中都有说明。同时，在移动端webView层，对html缓存机制做了支持（从笔者接触过的手游和相关APP来看，目前使用默认缓存机制的比较多），项目开发过程中缓存更新和清理方式也需要有针对性地选择使用。</p><h4 style="margin: 1.3em 0px 1em; padding: 0px; font-weight: bold;font-size: 1.2em;">参考文献：</h4><blockquote style="margin: 1.2em 0px; border-left: 4px solid rgb(221, 221, 221); padding: 0px 1em; color: rgb(119, 119, 119); quotes: none;"><p style="margin: 0px 0px 1.2em !important;">《HTML Living Standard》<br>《HTML5 Storage Wars - localStorage vs. IndexedDB vs. Web SQL》<br>《使用 HTML5 开发离线应用》<br>《Android WebView缓存机制总结》<br>《iOS: 聊聊 UIWebView 缓存》<br>《NSURLRequestCachePolicy—iOS缓存策略》<br>《H5 缓存机制浅析 - 移动端 Web 加载性能优化》<br>《关于 iOS 删除缓存的那些事儿》</p></blockquote><hr><p style="max-width: 100%; min-height: 1em; color: rgb(62, 62, 62); font-size: 16px; white-space: normal; background-color: rgb(255, 255, 255); box-sizing: border-box !important; word-wrap: break-word !important;"><strong style="max-width: 100%; line-height: 23.2727px; box-sizing: border-box !important; word-wrap: break-word !important;"><strong style="max-width: 100%; line-height: 23.2727px; box-sizing: border-box !important; word-wrap: break-word !important;"><strong style="max-width: 100%; line-height: 23.2727px; box-sizing: border-box !important; word-wrap: break-word !important;"><strong style="max-width: 100%; line-height: 23.2727px; box-sizing: border-box !important; word-wrap: break-word !important;"><br></strong></strong></strong></strong>
		            </div>
			    </div>
			    <div id="cnt2">        
					<h2 class="title">web前端规范</h2>
			        <!-- 文章内容 -->
			        <div class="show-content">
			          <h3>通用规范</h3>
						<ol>
						<li>tab键用两个空格代替<br>　　因为在不同系统的编辑工具对tab解析不一样，windows下的tab键是占四个空格的位置，而在linux下会变成占八个空格的位置（除非你  自己设定了tab键所占的位置长度）。</li>
						<li>每个样式属性或者每句代码后加 ";"<br> 方便压缩工具"断句"。</li>
						</ol>
						<h3>HTML规范</h3>
						<p><strong>HTML5 doctype</strong></p>
						<p>为每个 HTML 页面的第一行添加标准模式（standard mode）的声明，这样能够确保在每个浏览器中拥有一致的展现。</p>
						<pre class="hljs xml"><code class="xml">:::html
						<span class="hljs-meta">&lt;!DOCTYPE html&gt;</span>
						<span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>
						  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
						  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
						<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre>
						<p><strong>字符编码</strong></p>
						<p>通过明确声明字符编码，能够确保浏览器快速并容易的判断页面内容的渲染方式。这样做的好处是，可以避免在 HTML 中使用字符实体标记（character entity），从而全部与文档编码一致（约定一致采用<code>UTF-8</code>编码）。</p>
						<pre class="hljs asciidoc"><code class="asciidoc"><span class="hljs-meta">:::html</span>
						&lt;head&gt;
						<span class="hljs-code">  &lt;meta charset="UTF-8"&gt;</span>
						&lt;/head&gt;</code></pre>
						<p><strong> 文档模板</strong></p>
						<pre class="hljs xml"><code class="xml">:::html
						<span class="hljs-meta">&lt;!DOCTYPE HTML&gt;</span>
						<span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span>
						    <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>
						        <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">"utf-8"</span> /&gt;</span>
						        <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Sample page<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span>
						        <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">"stylesheet"</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"css_example_url"</span> /&gt;</span>
						        <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"js_example_url"</span>&gt;</span><span class="undefined"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
						    <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span>
						    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>
						        <span class="hljs-tag">&lt;<span class="hljs-name">section</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"page"</span>&gt;</span>
						            <span class="hljs-tag">&lt;<span class="hljs-name">header</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"header"</span>&gt;</span>
						            页头
						            <span class="hljs-tag">&lt;/<span class="hljs-name">header</span>&gt;</span>
						            <span class="hljs-tag">&lt;<span class="hljs-name">section</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"body"</span>&gt;</span>
						            主体
						            <span class="hljs-tag">&lt;/<span class="hljs-name">section</span>&gt;</span>
						            <span class="hljs-tag">&lt;<span class="hljs-name">footer</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"footer"</span>&gt;</span>
						            页尾
						            <span class="hljs-tag">&lt;/<span class="hljs-name">footer</span>&gt;</span>
						        <span class="hljs-tag">&lt;/<span class="hljs-name">section</span>&gt;</span>
						        <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="actionscript">
						        <span class="hljs-comment">// 你的代码</span>
						        </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
						    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span>
						<span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span></code></pre>
						<p><strong>IE 兼容模式</strong></p>
						<p>IE 支持通过特定的 &lt;meta&gt; 标签来确定绘制当前页面所应该采用的 IE 版本。除非有强烈的特殊需求，否则最好是设置为 edge mode，从而通知 IE 采用其所支持的最新的模式。</p>
						<pre class="hljs asciidoc"><code class="asciidoc"><span class="hljs-meta">:::html</span>
						&lt;meta http-equiv="X-UA-Compatible" content="IE=Edge"&gt;</code></pre>
						<p><strong>元素</strong></p>
						<ol>
						<li>
						<p>html5元素</p>
						<ul>
						<li>section 表示文档中的节、区段，可以和h1-h6一起来显示文档结构</li>
						<li>article 表示一块比较独立的内容或者主题内容，块级元素，比如blog的内容，报纸的文章</li>
						<li>aside 表示article以外的内容，而且应该和article有一定的关系，块级元素</li>
						<li>hgroup 表示一个文档、区段(section)的标题组合</li>
						<li>header 表示页眉,页头</li>
						<li>footer 表示页脚</li>
						<li>nav 表示导航内容</li>
						<li>figure 表示以相对独立的或外引的元素，如img video</li>
						<li>
						<p>figcaption 表示 figure内容的标题</p>
						<pre class="hljs xml"><code class="xml">  :::html
						  <span class="hljs-comment">&lt;!-- hgroup 示例 --&gt;</span>
						  <span class="hljs-tag">&lt;<span class="hljs-name">hgroup</span>&gt;</span>
						  <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>文档主标题<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span>
						  <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>文档副标题<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span>
						  <span class="hljs-tag">&lt;/<span class="hljs-name">hgroup</span>&gt;</span>

						  <span class="hljs-comment">&lt;!-- figure 示例 --&gt;</span>
						  <span class="hljs-tag">&lt;<span class="hljs-name">figure</span>&gt;</span>
						   <span class="hljs-tag">&lt;<span class="hljs-name">video</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"ogg"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">video</span>&gt;</span>
						   <span class="hljs-tag">&lt;<span class="hljs-name">figcaption</span>&gt;</span>Example<span class="hljs-tag">&lt;/<span class="hljs-name">figcaption</span>&gt;</span>
						  <span class="hljs-tag">&lt;/<span class="hljs-name">figure</span>&gt;</span>

						  <span class="hljs-tag">&lt;<span class="hljs-name">figure</span>&gt;</span>
						   <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"img"</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">"Example image"</span> /&gt;</span>
						   <span class="hljs-tag">&lt;<span class="hljs-name">figcaption</span>&gt;</span>Example image<span class="hljs-tag">&lt;/<span class="hljs-name">figcaption</span>&gt;</span>
						  <span class="hljs-tag">&lt;/<span class="hljs-name">figure</span>&gt;</span></code></pre>
						</li>
						</ul>
						</li>
						<li>
						<p>结构性元素</p>
						<ul>
						<li>p 表示段落。只能包含内联元素，不能包含块级元素;</li>
						<li>div 本身无特殊含义，可用于布局。几乎可以包含任何元素;</li>
						<li>br 表示换行符;</li>
						<li>hr 表示水平分割线;</li>
						<li>h1-h6 表示标题。其中 h1 用于表示当前页面最重要的内容的标题;</li>
						<li>blockquote 表示引用，可以包含多个段落。请勿纯粹为了缩进而使用 blockquote，大部分浏览器默认将 blockquote 渲染为带有左右缩进;</li>
						<li>pre 表示一段格式化好的文本;</li>
						</ul>
						</li>
						<li>
						<p>头部元素</p>
						<ul>
						<li>title 每个页面必须有且仅有一个 title 元素;</li>
						<li>base 可用场景：首页、频道等大部分链接都为新窗口打开的页面;</li>
						<li>link link 用于引入 css 资源时，可省去 media(默认为all) 和 type(默认为text/css) 属性;</li>
						<li>style type 默认为 text/css，可以省去;</li>
						<li>script type 属性可以省去; 不赞成使用lang属性; 不要使用古老的&lt;!– //–&gt;这种hack脚本, 它用于阻止第一代浏览器（Netscape 1和Mosaic）将脚本显示成文字;</li>
						<li>noscript 在用户代理不支持 JavaScript 的情况下提供说明;</li>
						</ul>
						</li>
						<li>
						<p>文本元素</p>
						<ul>
						<li>a a 存在 href 属性时表示链接，无 href 属性但有 name 属性表示锚点;</li>
						<li>em,strong em 表示句意强调，加与不加会引起语义变化，可用于表示不同的心情或语调; strong 表示重要性强调，可用于局部或全局，strong强调的是重要性，不会改变句意;</li>
						<li>abbr 表示缩写;</li>
						<li>sub,sup 主要用于数学和化学公式，sup还可用于脚注;</li>
						<li>span 本身无特殊含义;</li>
						<li>ins,del 分别表示从文档中增加(插入)和删除</li>
						</ul>
						</li>
						<li>
						<p>媒体元素</p>
						<ul>
						<li>img 请勿将img元素作为定位布局的工具，不要用他显示空白图片; 必要时给img元素增加alt属性;</li>
						<li>object 可以用来插入Flash;</li>
						</ul>
						</li>
						<li>
						<p>列表元素</p>
						<ul>
						<li>dl 表示关联列表，dd是对dt的解释; dt和dd的对应关系比较随意：一个dt对应多个dd、多个dt对应一个dd、多个dt对应多个dd，都合法; 可用于名词/单词解释、日程列表、站点目录;</li>
						<li>ul 表示无序列表;</li>
						<li>ol 表示有序列表, 可用于排行榜等;</li>
						<li>li 表示列表项，必须是ul/ol的子元素;</li>
						</ul>
						</li>
						<li>
						<p>表单元素</p>
						<ul>
						<li>推荐使用 button 代替 input，但必须声明 type;</li>
						<li>表单元素的 name 不能设定为 action, enctype, method, novalidate, target, submit 会导致表单提交混乱    </li>
						</ul>
						</li>
						</ol>
						<p><strong>属性顺序</strong></p>
						<ol>
						<li>
						<p>HTML 属性应当按照以下给出的顺序依次排列，确保代码的易读性。</p>
						<ul>
						<li><code>class</code></li>
						<li>
						<code>id</code> 、 <code>name</code>
						</li>
						<li><code>data-*</code></li>
						<li>
						<code>src</code>、<code>for</code>、 <code>type</code>、 <code>href</code>
						</li>
						<li>
						<code>title</code>、<code>alt</code>
						</li>
						<li>
						<code>aria-*</code>、 <code>role</code>
						</li>
						</ul>
						</li>
						<li>
						<p>class用于标识高度可复用组件，因此应该排在首位。id 用于标识具体组件，应当谨慎使用（例如，页面内的书签），因此排在第二位。如：</p>
						<pre class="hljs stylus"><code class="stylus">:::<span class="hljs-selector-tag">html</span>
						&lt;<span class="hljs-selector-tag">a</span> class=<span class="hljs-string">"..."</span> id=<span class="hljs-string">"..."</span> data-modal=<span class="hljs-string">"toggle"</span> href=<span class="hljs-string">"#"</span>&gt;
						 Example link
						&lt;/a&gt;
						 &lt;<span class="hljs-selector-tag">input</span> class=<span class="hljs-string">"form-control"</span> type=<span class="hljs-string">"text"</span>&gt;
						 &lt;<span class="hljs-selector-tag">img</span> src=<span class="hljs-string">"..."</span> alt=<span class="hljs-string">"..."</span>&gt;</code></pre>
						</li>
						</ol>
						<p><strong>文件和目录命名约定</strong></p>
						<ol>
						<li>
						<em>一律小写，必须是英文单词或者汉语拼音，以英语单词优先，多个单词以连字符 ( - ) 连接。</em> 只能出现小写引文字母，数字和连字符。</li>
						<li>很多浏览器会将含有这些词的作为广告拦截： ad、ads、adv、banner、sponsor、gg、guangg、guanggao等 页面中尽量避免采用以上词汇来命名。</li>
						<li>该命令规范适用于所有前端维护的内容和相关目录。(html, css, js, png, gif, jpg, ico)。</li>
						</ol>
						<p><strong>空格/标签/注释</strong></p>
						<ol>
						<li>用两个空格来代替制表符（tab） —— 这是唯一能保证在所有环境下获得一致展现的方法；</li>
						<li>嵌套元素应当缩进一次 —— 即两个空格；</li>
						<li>对于属性的定义，确保全部使用双引号，绝不要使用单引号；</li>
						<li>不要省略可选的结束标签，如：<code>&lt;/li&gt;</code>,<code>&lt;/body&gt;</code>；</li>
						<li>习惯性书写注释，方便日后维护；</li>
						</ol>
						<hr>
						<p><strong>文件编码约定</strong></p>
						<p>所有文件统一采用<em>UTF-8</em>无BOM编码。换行格式为 unix 格式。</p>
						<p><strong> id和class命名约定</strong></p>
						<ol>
						<li>id 和 class 的命名基本原则:<em> 内容优先，表现为辅</em>。首先根据内容来命名，如:<code>#header</code>,<code>#footer</code>,<code>.main-nav</code>.如根据内容无法找到合适的命名，可以再结合表现进行命名，如：<code>col-main</code>, <code>col-sub</code>, <code>col-extra</code>,<code>blue-box</code>
						</li>
						<li>id 和 class 的名称一律小写，多个单词以连字符连接，如： <code>main-wrap</code>
						</li>
						<li>id 和 class 的名称只能出现，小写字母，数字和连字符( - )(js钩子除外)</li>
						<li>id 和 class 的名称<em>尽量使用英文单词命名</em>,如确实找不到合适的单词，可以使用拼音，如：<code>zhidao-com</code>
						</li>
						<li>在不影响语意的情况下，id 和 class 的名称 可以适当使用缩写，如: <code>col</code>, <code>nav</code>, <code>hd</code>, <code>bd</code>, <code>fd</code>(<em> 缩写只用来表示结构，不允许写任何样式</em>)。不要自造缩写。</li>
						<li>class 对于选中命名<code>.selected</code>;对于hover，支持伪类使用<code>:hover</code>，不支持的使用 <code>.hover</code>，隐藏使用<code>.hide</code> 。</li>
						<li>id 和 class 的选择，如果只使用一次，使用id,如果使用多次使用class，如果需要和js交互，使用id,如果需要交互并且页面中有大量重复，请参见下一条。</li>
						<li>对于作为js钩子的 id 和 class 命名规则为以”J_“开头(J,象形钩子的形状)，后面加上原应有的命名，在使用class的时候需要放在最前面。如:<code>class="J_tab-content some-mod-content"</code>。（注意：钩子，不允许在css中定义任何的样式效果）</li>
						<li>很多浏览器会将含有这些词的作为广告拦截： <code>ad</code>、<code>ads</code>、<code>adv</code>、<code>banner</code>、<code>sponsor</code>、<code>gg</code>、<code>guangg</code>、<code>guanggao</code>等 页面中尽量避免采用以上词汇来命名。</li>
						</ol>
						<p><strong>文件引用</strong></p>
						<ol>
						<li>页面中不允许出现css内容(包括行内样式和style)</li>
						<li>每个页面中至多包括3个css文件，1个 产品级 1个模块级 1个页面级别</li>
						</ol>
						<p><strong>选择器</strong></p>
						<ol>
						<li>命名比较短的词，或者缩写的不允许直接定义样式，如：.title,.hd,.bd,.body.必须用上级节点进行限定,如：.recommend-mod .title</li>
						</ol>
						<p><strong>通用结构</strong></p>
						<ol>
						<li>页面中的块采用如下结构<pre class="hljs applescript"><code class="applescript">:::html
						&lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">"mod recommend-mod"</span>&gt;
						 &lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">"hd recommend-title"</span>&gt;Tilte &lt;/<span class="hljs-keyword">div</span>&gt;
						 &lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">"bd recommend-body"</span>&gt;<span class="hljs-built_in">contents</span>&lt;/<span class="hljs-keyword">div</span>&gt;
						 &lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">"ft recommend-footer"</span>&gt;footer &lt;/<span class="hljs-keyword">div</span>&gt;
						&lt;/<span class="hljs-keyword">div</span>&gt;</code></pre>
						</li>
						</ol>
						<p>没有内容的部分可以省略，其中用来表示结构的 mod hd bd ft 不允许直接定义样式（避免嵌套带来样式问题）,需要定义样式的时候需要另外增加class以控制样式如：</p>
						<pre class="hljs applescript"><code class="applescript">:::html    
						&lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">"mod recommend-mod"</span>&gt;
						  &lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">"hd recommend-title"</span>&gt;Tilte &lt;/<span class="hljs-keyword">div</span>&gt;
						  &lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">"bd recommend-body"</span>&gt;<span class="hljs-built_in">contents</span>&lt;/<span class="hljs-keyword">div</span>&gt;
						  &lt;<span class="hljs-keyword">div</span> <span class="hljs-built_in">class</span>=<span class="hljs-string">"ft recommend-footer"</span>&gt;footer &lt;/<span class="hljs-keyword">div</span>&gt;
						&lt;/<span class="hljs-keyword">div</span>&gt;</code></pre>
						<p>当2个以上的结构不存在的时候可以不是采用此结构，如，没有hd和ft,bd也可以省略</p>
						<p><strong>多选择器规则之间换行</strong><br>当样式针对多个选择器时每个选择器占一行</p>
						<blockquote><p>/<em> 推荐的写法 </em>/<br>  a.btn,<br>  input.btn,<br>  input[type="button"] {<br>     ......<br>  }</p></blockquote>
						<p><strong>z-index</strong></p>
						<ol>
						<li>自己写的z-index的值不能超过 100 (通用组的除外)</li>
						<li>页面中的元素内容的z-index不能超过10(popup poptip除外)，需要按照内容定义1 2 3 4不允许直接使用如1000，9999</li>
						<li>popup poptip的z-index需要按照内容使用 99以下，10以上的值（11,12,13，也可以小于10），不允许直接使用1000，9999之类大值</li>
						</ol>
						<p>现在通用z-index记录,使用时请避开和灵活使用</p>
						<table>
						<thead>
						<tr>
						<th><strong> z-index </strong></th>
						<th style="text-align:center"><strong>使用者</strong></th>
						<th style="text-align:right"><strong> 类型 </strong></th>
						</tr>
						</thead>
						<tbody>
						<tr>
						<td>&lt;10</td>
						<td style="text-align:center">page-content</td>
						<td style="text-align:right">页面级别</td>
						</tr>
						<tr>
						<td>&gt;10, &lt;99</td>
						<td style="text-align:center">page-popup</td>
						<td style="text-align:right">页面级别</td>
						</tr>
						<tr>
						<td>20</td>
						<td style="text-align:center">usercard用户名片</td>
						<td style="text-align:right">common通用</td>
						</tr>
						<tr>
						<td></td>
						<td style="text-align:center">MSG气泡消息</td>
						<td style="text-align:right">common通用</td>
						</tr>
						<tr>
						<td></td>
						<td style="text-align:center">Dialog-Cover</td>
						<td style="text-align:right">common通用</td>
						</tr>
						<tr>
						<td></td>
						<td style="text-align:center">Dialog</td>
						<td style="text-align:right">common通用</td>
						</tr>
						</tbody>
						</table>
						<h3>css规范</h3>
						<p><strong>css属性顺序</strong></p>
						<ol>
						<li>显示属性；</li>
						<li>元素位置；</li>
						<li>元素属性；</li>
						<li>元素内容属性；</li>
						<li>
						<p>css书写顺序：</p>
						<pre class="hljs stylus"><code class="stylus">:::<span class="hljs-selector-tag">html</span>
						例子:
						<span class="hljs-selector-class">.header</span> {
						 <span class="hljs-comment">/* 显示属性 */</span>
						 <span class="hljs-attribute">display</span> || visibility
						 <span class="hljs-attribute">list-style</span>
						 <span class="hljs-attribute">position</span>
						 <span class="hljs-attribute">top</span> || right || bottom || left
						 <span class="hljs-attribute">z-index</span>
						 <span class="hljs-attribute">clear</span>
						 <span class="hljs-attribute">float</span>

						 <span class="hljs-comment">/* 自身属性 */</span>
						 <span class="hljs-attribute">width</span>
						 <span class="hljs-attribute">max-width</span> || min-width
						 <span class="hljs-attribute">height</span>
						 <span class="hljs-attribute">max-height</span> || min-height
						 <span class="hljs-attribute">overflow</span> || clip
						 <span class="hljs-attribute">margin</span> 
						 <span class="hljs-attribute">padding</span>
						 <span class="hljs-attribute">outline</span>
						 <span class="hljs-attribute">border</span>
						 <span class="hljs-attribute">background</span>

						 <span class="hljs-comment">/* 文本属性 */</span>
						 <span class="hljs-attribute">color</span>
						 <span class="hljs-attribute">font</span>
						 <span class="hljs-attribute">text-overflow</span>
						 <span class="hljs-attribute">text-align</span>
						 <span class="hljs-attribute">text-indent</span>
						 <span class="hljs-attribute">line-height</span>
						 <span class="hljs-attribute">white-space</span>
						 <span class="hljs-attribute">vertical-align</span>
						 <span class="hljs-attribute">cursor</span>
						 <span class="hljs-attribute">content</span>
						}</code></pre>
						</li>
						</ol>
						<p><strong>css写法</strong></p>
						<ol>
						<li>小图片（必须）sprite 合并</li>
						<li>每个样式属性后加 ";"</li>
						<li>
						<p>禁止将样式写为单行</p>
						<blockquote><p>如<br>.hotel-content {margin: 10px; background-color: #efefef;}<br>单行显示不好注释，不好备注，这应该是压缩工具的活儿~</p></blockquote>
						</li>
						<li>
						<p>禁止使用行内（inline）样式</p>
						</li>
						<li>
						<p>禁止使用"*"来选择元素</p>
						<blockquote><p>/*别这样写*/<br>* {<br> margin: 0;<br> padding: 0;<br>}</p></blockquote>
						<p> 这样写是没有必要的，一些元素在浏览器中默认有margin或padding值，但是只是部分元素，没有必要将所有元素的margin、padding值都置为0。</p>
						</li>
						<li>
						<p>带前缀的属性<br>当使用特定浏览器带有前缀的属性时，通过缩进的方式，让每个属性的值在垂直方向对齐，这样便于多行编辑。如：    </p>
						<pre class="hljs css"><code class="css"><span class="hljs-selector-class">.selector</span> {
						  <span class="hljs-attribute">-webkit-box-shadow</span>: <span class="hljs-number">0</span> <span class="hljs-number">1px</span> <span class="hljs-number">2px</span> <span class="hljs-built_in">rgba</span>(0,0,0,.15);
						       <span class="hljs-attribute">box-shadow</span>: <span class="hljs-number">0</span> <span class="hljs-number">1px</span> <span class="hljs-number">2px</span> <span class="hljs-built_in">rgba</span>(0,0,0,.15);
						}</code></pre>
						</li>
						<li>
						<p>优化css选择器<br> css选择器是从右边到左边进行匹配的。如：</p>
						<pre class="hljs css"><code class="css"><span class="hljs-selector-id">#header</span> <span class="hljs-selector-tag">a</span> {
						 <span class="hljs-attribute">color</span>: <span class="hljs-number">#444</span>;
						}</code></pre>
						<p> 浏览器会检查整个文档中的<strong>所有链接</strong>，然后浏览器并不仅仅检查每个链接的父元素，还要遍历文档树去查找 <code>id</code> 为 <code>header</code> 的祖先元素，如果被评估的链接不是 header 的后代，那么浏览器就要向上一级遍历知道文档的根节点。针对此问题，有以下几个解决方法：</p>
						<ul>
						<li>避免使用通配规则<br>除了传统意义的通配选择符之外还包括相邻兄弟选择符, 子选择符, 后代选择符和属性选择符。推荐id、class和标签选择符。   </li>
						<li>不要限定id选择符<br>页面中指定一个id只能对应一个元素，所以没有必要添加额外添加限定符，如： <code>div#header</code> ，应该简化为： <code>#header</code>（<strong>提权的除外</strong>）。</li>
						<li>不要限定类选择器<br>不要用具体的标签限定类选择符，而是根据实际情况对类名进行扩展。例如： <code>ul.recommend</code> ，改成 <code>.recommend-list</code> 或者 <code>.list-recommend</code>。    </li>
						<li>让规则越具体越好<br>尽量不要使用 <code>ul li a</code> 这样长的选择符，最好使用  <code>.list-anchor</code> 之类的选择符。    </li>
						<li>避免使用后代选择符<br>通常处理后代选择符开销最高，使用字选择符更高效，最好使用下一条代替。</li>
						<li>避免使用标签子选择符<br>如果有如： <code>#header &gt; li &gt; a</code>，这样基于子标签的自选择符，那么应该使用一个class来关联每个元素如： <code>.header-anchor</code>。尽量使用具体的类代替子选择符。</li>
						</ul>
						</li>
						</ol>
						<hr>
						<h3>前端规范之JavaScript</h3>
						<p><strong>命名规范</strong></p>
						<ol>
						<li>
						<p>文件命名可读性强<br> 文件夹、文件的命名与命名空间应能代表代码功能，可读性强。</p>
						</li>
						<li>
						<p>函数命名<br>驼峰命名方式</p>
						<pre class="hljs asciidoc"><code class="asciidoc"><span class="hljs-meta">:::javascript</span>
						function funName() {}</code></pre>
						</li>
						<li>
						<p>常量<br>大写</p>
						<pre class="hljs php"><code class="php"> :::javascript
						 <span class="hljs-keyword">var</span> VARIABLENAME</code></pre>
						</li>
						<li>
						<p>变量<br> 驼峰命名</p>
						<pre class="hljs asciidoc"><code class="asciidoc"><span class="hljs-meta">:::javascript</span>
						var variableName</code></pre>
						</li>
						</ol>
						<p><strong> 编码规则</strong></p>
						<ol>
						<li>
						<p>排版缩进<br>采用统一的缩进方式排版代码。缩进为2个ASCII空格</p>
						<pre class="hljs asciidoc"><code class="asciidoc"><span class="hljs-meta">:::javascript</span>
						If(condition1 || condition2) {
						<span class="hljs-code">  action1;</span>
						} else if (condition3 &amp;&amp; condition4) {
						<span class="hljs-code"> action2;</span>
						} else if (condition5
						<span class="hljs-code">       &amp;&amp; condition6</span>
						<span class="hljs-code">       &amp;&amp; condition7</span>
						<span class="hljs-code">       &amp;&amp; condition8) {</span>
						<span class="hljs-code"> action2;</span>
						} else {
						<span class="hljs-code"> default action;</span>
						}</code></pre>
						</li>
						<li>
						<p>关键词、条件括弧后面使用空格；运算操作符号两侧使用空格；语句分割符‘,’后面使用空格</p>
						<pre class="hljs markdown"><code class="markdown">:::javascript
						var name[空格]=[空格]value;
						if[<span class="hljs-string">空格</span>](<span class="hljs-link">a,[空格]b</span>) {
						}</code></pre>
						</li>
						<li>
						<p>左大括号"{"可以居行尾，也可写在下行首（独自一行）；右大括号"}"单独占一行，居行首</p>
						<pre class="hljs asciidoc"><code class="asciidoc"><span class="hljs-meta">:::javascript</span>
						if (a &amp;&amp; b) {
						<span class="hljs-section"> }
						------------------------</span>
						if (a &amp;&amp; b) 
						{
						}</code></pre>
						</li>
						<li>
						<p>句末必须用分号结尾</p>
						<pre class="hljs asciidoc"><code class="asciidoc"><span class="hljs-meta">:::javascript</span>
						var fn = function () {
						};//这里没有分号的话，脚本解析器会报错！！！
						(function () {
						<span class="hljs-code">   alert(1);</span>
						})();</code></pre>
						</li>
						<li>
						<p>单行过长应在适当位置予以换行,增强可读性<br>if 语句括号中的条件若过多过长，应予以折行；折行后，||、&amp;&amp; 等符号应与 “(” 后的第一个字母纵向对齐</p>
						<pre class="hljs asciidoc"><code class="asciidoc"><span class="hljs-meta">:::javascript</span>
						if (condition1 
						<span class="hljs-code"> &amp;&amp; condition2 </span>
						<span class="hljs-code"> || condition3) {</span>
						}</code></pre>
						</li>
						<li>
						<p>if、while、for、do语句的执行体总是用"{"和"}"括起来，即使在其结构体内只有一条语句</p>
						<pre class="hljs asciidoc"><code class="asciidoc"><span class="hljs-meta">:::javascript</span>
						if (s==100) {
						<span class="hljs-code"> alert('shit!');</span>
						}</code></pre>
						</li>
						<li>
						<p>语法意义相互独立的代码将用空行分隔</p>
						<pre class="hljs asciidoc"><code class="asciidoc"><span class="hljs-meta">:::javascript</span>
						a<span class="hljs-code">++; b+</span>+;   //！！！避免同一行书写两个表达式
						if (a &gt; b) {
						<span class="hljs-code"> value = a;  //行间不用空行间隔</span>
						}

						var variableName = value;   //与上一代码行使用空行间隔</code></pre>
						</li>
						</ol>
						<p><strong>注释规范</strong></p>
						<ol>
						<li>
						<p>文件注释</p>
						<ul>
						<li>文件注释要标明作者、文件版本、创建/修改时间、重大版本修改记录</li>
						<li>函数描述</li>
						<li>
						<p>文件版本、创建或者修改时间、功能、作者</p>
						<pre class="hljs php"><code class="php"> :::javascript
						 <span class="hljs-comment">/**
						 * <span class="hljs-doctag">@file</span> Image.js
						 * <span class="hljs-doctag">@description</span> 功能详细描述
						 */</span></code></pre>
						</li>
						<li>
						<p>函数或者类等都要添加头描述</p>
						<pre class="hljs php"><code class="php"> :::javascript
						 <span class="hljs-comment">/**
						 * 简述
						 *
						 * 功能详细描述
						 *
						 * <span class="hljs-doctag">@param</span> &lt;String&gt; arg1 参数1
						 * <span class="hljs-doctag">@param</span> &lt;Number&gt; arg2 参数2，默认为0
						 * <span class="hljs-doctag">@return</span> &lt;Boolean&gt; 看xxx是否成功
						 */</span>
						 <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fooFunction</span> <span class="hljs-params">(arg1, arg2)</span> </span>{
						 }</code></pre>
						</li>
						</ul>
						</li>
						<li>
						<p>操作注释</p>
						<ul>
						<li>单行注释,写在代码上面</li>
						<li>
						<p>多行注释</p>
						<pre class="hljs asciidoc"><code class="asciidoc"><span class="hljs-meta">:::javascript</span>
						/*
						<span class="hljs-bullet">* </span>注释操作说明
						<span class="hljs-strong">*/
						for( var i = 0; i &lt; obj.lenght; i++) {
						}</span></code></pre>
						</li>
						<li>
						<p>注释标签参考</p>
						</li>
						</ul>
						</li>
						</ol>
						<table>
						<thead>
						<tr>
						<th>
						<em> </em>标签<em> </em>
						</th>
						<th style="text-align:center"><strong>    描述 </strong></th>
						</tr>
						</thead>
						<tbody>
						<tr>
						<td>@addon</td>
						<td style="text-align:center">把一个函数标记为另一个函数的扩张，另一个函数的定义不在源文件中。</td>
						</tr>
						<tr>
						<td>@argument</td>
						<td style="text-align:center">用大括号中的自变量类型描述一个自变量。</td>
						</tr>
						<tr>
						<td>@author</td>
						<td style="text-align:center">函数/类作者的姓名。</td>
						</tr>
						<tr>
						<td>@base</td>
						<td style="text-align:center">如果类是继承得来，定义提供的类名称。</td>
						</tr>
						<tr>
						<td>@class</td>
						<td style="text-align:center">用来给一个类提供描述，不能用于构造器的文档中。</td>
						</tr>
						<tr>
						<td>@constructor</td>
						<td style="text-align:center">描述一个类的构造器。</td>
						</tr>
						<tr>
						<td>@deprecated</td>
						<td style="text-align:center">表示函数/类已被忽略。</td>
						</tr>
						<tr>
						<td>@exception</td>
						<td style="text-align:center">描述函数/类产生的一个错误。</td>
						</tr>
						<tr>
						<td>@exec</td>
						<td style="text-align:center"></td>
						</tr>
						<tr>
						<td>@extends</td>
						<td style="text-align:center">表示派生出当前类的另一个类。</td>
						</tr>
						<tr>
						<td>@fileoverview</td>
						<td style="text-align:center">表示文档块将用于描述当前文件。这个标签应该放在其它任何标签之前。</td>
						</tr>
						<tr>
						<td>@final</td>
						<td style="text-align:center">指出函数/类。</td>
						</tr>
						<tr>
						<td>@ignore</td>
						<td style="text-align:center">让jsdoc忽视随后的代码。</td>
						</tr>
						<tr>
						<td>@link</td>
						<td style="text-align:center">类似于@link标签，用于连接许多其它页面。</td>
						</tr>
						<tr>
						<td>@member</td>
						<td style="text-align:center">定义随后的函数为提供的类名称的一个成员。</td>
						</tr>
						<tr>
						<td>@param</td>
						<td style="text-align:center">用大括号中的参数类型描述一个参数。</td>
						</tr>
						<tr>
						<td>@private</td>
						<td style="text-align:center">表示函数/类为私有，不应包含在生成的文档中。</td>
						</tr>
						<tr>
						<td>@requires</td>
						<td style="text-align:center">表示需要另一个函数/类。</td>
						</tr>
						<tr>
						<td>@return</td>
						<td style="text-align:center">描述一个函数的返回值。</td>
						</tr>
						<tr>
						<td>@returns</td>
						<td style="text-align:center">描述一个函数的返回值。</td>
						</tr>
						<tr>
						<td>@see</td>
						<td style="text-align:center">连接到另一个函数/类。</td>
						</tr>
						<tr>
						<td>@throws</td>
						<td style="text-align:center">描述函数/类可能产生的错误。</td>
						</tr>
						<tr>
						<td>@type</td>
						<td style="text-align:center">指定函数/成员的返回类型。</td>
						</tr>
						<tr>
						<td>@version</td>
						<td style="text-align:center">函数/类的版本号。</td>
						</tr>
						</tbody>
						</table>
						<p><strong>条件判断的陷阱</strong></p>
						<ol>
						<li>
						<p>在if判断中，使用<code>===</code>作比较,避免掉入<code>==</code>造成的陷阱 </p>
						<ul>
						<li>在条件判断时，这样的一些值表示false：<code>null</code>，<code>undefined</code>，字符串<code>''</code>，数字<code>0</code>，<code>NaN</code>
						</li>
						<li>
						<p>而在<code>==</code>时，则会有一些让人难以理解的陷阱,如：</p>
						<pre class="hljs javascript"><code class="javascript">(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>{ 
						  <span class="hljs-keyword">var</span> <span class="hljs-literal">undefined</span>; 
						  <span class="hljs-literal">undefined</span> == <span class="hljs-literal">null</span>; <span class="hljs-comment">// true </span>
						  <span class="hljs-number">1</span> == <span class="hljs-literal">true</span>; <span class="hljs-comment">//true </span>
						  <span class="hljs-number">2</span> == <span class="hljs-literal">true</span>; <span class="hljs-comment">// false </span>
						  <span class="hljs-number">0</span> == <span class="hljs-literal">false</span>; <span class="hljs-comment">// true </span>
						  <span class="hljs-number">0</span> == <span class="hljs-string">''</span>; <span class="hljs-comment">// true </span>
						  <span class="hljs-literal">NaN</span> == <span class="hljs-literal">NaN</span>;<span class="hljs-comment">// false </span>
						  [] == <span class="hljs-literal">false</span>; <span class="hljs-comment">// true </span>
						  [] == ![]; <span class="hljs-comment">// true </span>
						})();</code></pre>
						</li>
						<li>
						<p>对于不同类型的 <code>==</code> 判断，有这样一些规则，顺序自上而下：</p>
						<blockquote><p>1.<code>undefined</code>与<code>null</code>相等<br>2.一个是<code>number</code>一个是<code>string</code>时，会尝试将<code>string</code>转换为<code>number</code><br>3.尝试将<code>boolean</code>转换为<code>number</code>，<code>0</code>或<code>1</code><br>4.尝试将<code>Object</code>转换成<code>number</code>或<code>string</code>，取决于另外一个对比量的类型</p></blockquote>
						</li>
						</ul>
						</li>
						</ol>
						<p>所以，对于<code>0</code>、空字符串的判断，建议使用 <code>===</code> 。<code>===</code>会先判断两边的值类型，类型不匹配时为<code>false</code>。</p>
						<p><strong>简单类型转换</strong></p>
						<ol>
						<li>number to string的转换，建议使用 <code>1 + ''</code>或<code>String(1)</code>，不使用<code>new String(1)</code>或<code>1.toString()</code>的方式。</li>
						<li>
						<p>string to number的转换，建议使用<code>parseInt</code>，必须显式指定第二个参数的进制。下面的例子展示了不指定进制的风险：</p>
						<pre class="hljs arduino"><code class="arduino"><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">'08'</span>); <span class="hljs-comment">// 0 </span>
						<span class="hljs-built_in">parseInt</span>(<span class="hljs-string">'08'</span>, <span class="hljs-number">10</span>); <span class="hljs-comment">//8</span></code></pre>
						</li>
						<li>
						<p>float to integer的转换，建议使用<code>Math.floor/Math.round/Math.ceil</code>方法，不使用<code>parseInt</code>。</p>
						</li>
						</ol>
						<p><strong>字符串拼接</strong><br>字符串拼接，应使用数组保存字符串片段，使用时调用<code>join</code>方法。避免使用<code>+</code>或<code>+=</code>的方式拼接较长的字符串，每个字符串都会使用一个小的内存片段，过多的内存片段会影响性能。如:</p>
						<pre class="hljs sqf"><code class="sqf">不好的拼接方式，+=

						var <span class="hljs-built_in">str</span> = <span class="hljs-string">''</span>; 
						<span class="hljs-keyword">for</span> (var i = <span class="hljs-number">0</span>, len = <span class="hljs-built_in">list</span>.length; i &lt; len; i++) { 
						  <span class="hljs-built_in">str</span>+= <span class="hljs-string">'&lt;div&gt;'</span> + <span class="hljs-built_in">list</span>[i] + <span class="hljs-string">'&lt;/div&gt;'</span>; 
						} 
						dom.innerHTML = <span class="hljs-built_in">str</span>;

						正确拼接方式，Array的push+<span class="hljs-built_in">join</span>

						var <span class="hljs-built_in">str</span> = []; 
						<span class="hljs-keyword">for</span> (var i = <span class="hljs-number">0</span>, len = <span class="hljs-built_in">list</span>.length; i &lt; len; i++) { 
						  <span class="hljs-built_in">str</span>.push(<span class="hljs-string">'&lt;div&gt;'</span>+ <span class="hljs-built_in">list</span>[i] + <span class="hljs-string">'&lt;/div&gt;'</span>); 
						} 
						dom.innerHTML = <span class="hljs-built_in">str</span>.<span class="hljs-built_in">join</span>(<span class="hljs-string">''</span>);</code></pre>
						<p><strong>获取元素</strong></p>
						<ol>
						<li>
						<p>获取单个元素</p>
						<ul>
						<li>
						<p>通常，我们使用<code>document.getElementById</code>来获取<code>dom</code>元素，避免使用<code>document.all</code>。<code>document.getElementById</code>是标准方法，兼容所有浏览器</p>
						<pre class="hljs xml"><code class="xml">ie浏览器会混淆元素的id和name属性，document.getElementById可能获得不期望的元素。
						在对元素的id与name属性的命名需要非常小心，应使用不同的命名法。
						下面是一个name与id冲突的例子：

						<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"test"</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"test"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>
						<span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">"alert(document.getElementById('test').tagName)"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
						<span class="hljs-comment">&lt;!-- ie6下为INPUT --&gt;</span></code></pre>
						</li>
						</ul>
						</li>
						</ol>
			        </div>
			    </div>
			    <div id="cnt3">
					<h2 class="title">JavaScript异步编程</h2>
					<article id="post-698" class="post-698 post type-post status-publish format-standard hentry category-js tag-asynchronous tag-event-loop tag-async">		
						<div class="entry-content">
						<div id="toc_container" class="toc_light_blue no_bullets" style="width: auto; display: table;"><ul class="toc_list" style="display: block;"><li><a href="#i"><span class="toc_number toc_depth_1">1</span> 前言</a></li><li><a href="#i-2"><span class="toc_number toc_depth_1">2</span> 同步与异步</a><ul><li><ul><li><a href="#i-3"><span class="toc_number toc_depth_3">2.0.1</span> 多线程</a></li><li><a href="#JavaScript"><span class="toc_number toc_depth_3">2.0.2</span> JavaScript单线程</a></li><li><a href="#i-4"><span class="toc_number toc_depth_3">2.0.3</span> 并行与并发</a></li></ul></li></ul></li><li><a href="#JavaScript-2"><span class="toc_number toc_depth_1">3</span> JavaScript异步机制</a></li><li><a href="#Concurrency_model"><span class="toc_number toc_depth_1">4</span> 并发模型（Concurrency model）</a><ul><li><ul><li><a href="#i-5"><span class="toc_number toc_depth_3">4.0.1</span> 堆栈与队列</a></li></ul></li><li><a href="#Event_Loop"><span class="toc_number toc_depth_2">4.1</span> 事件循环（Event Loop）</a><ul><li><a href="#i-6"><span class="toc_number toc_depth_3">4.1.1</span> 任务</a></li><li><a href="#i-7"><span class="toc_number toc_depth_3">4.1.2</span> 事件循环流程</a><ul><li><a href="#i-8"><span class="toc_number toc_depth_4">4.1.2.1</span> 并发模型与事件循环</a></li></ul></li><li><a href="#setTimeout82300"><span class="toc_number toc_depth_3">4.1.3</span> 再谈setTimeout(…0)</a></li><li><a href="#Web_Workers"><span class="toc_number toc_depth_3">4.1.4</span> Web Workers</a></li></ul></li></ul></li><li><a href="#JavaScript-3"><span class="toc_number toc_depth_1">5</span> JavaScript异步实现</a><ul><li><ul><li><a href="#i-9"><span class="toc_number toc_depth_3">5.0.1</span> 参考：</a></li></ul></li></ul></li></ul></div>
								<h2><span id="i">前言</span></h2>
								<p>如果你有志于成为一个优秀的前端工程师，或是想要深入学习JavaScript，异步编程是必不可少的一个知识点，这也是区分初级，中级或高级前端的依据之一。如果你对异步编程没有太清晰的概念，那么我建议你花点时间学习JavaScript异步编程，如果你对异步编程有自己的独特理解，也欢迎阅读本文，一起交流。</p>
								<h2><span id="i-2">同步与异步</span></h2>
								<p>介绍异步之前，回顾一下，所谓同步编程，就是计算机一行一行按顺序依次执行代码，当前代码任务耗时执行会阻塞后续代码的执行。</p>
								<blockquote>
								<p>同步编程，即是一种典型的请求-响应模型，当请求调用一个函数或方法后，需等待其响应返回，然后执行后续代码。</p>
								</blockquote>
								<p>一般情况下，同步编程，代码按序依次执行，能很好的保证程序的执行，但是在某些场景下，比如读取文件内容，或请求服务器接口数据，需要根据返回的数据内容执行后续操作，读取文件和请求接口直到数据返回这一过程是需要时间的，网络越差，耗费时间越长，如果按照同步编程方式实现，在等待数据返回这段时间，JavaScript是不能处理其他任务的，此时页面的交互，滚动等任何操作也都会被阻塞，这显然是及其不友好，不可接受的，而这正是需要异步编程大显身手的场景，如下图，耗时任务A会阻塞任务B的执行，等到任务A执行完才能继续执行B：</p>
								<p><img src="http://blog.codingplayboy.com/wp-content/uploads/2017/04/sync-flow.png" alt="同步编程任务阻塞流程"></p>
								<p>当使用异步编程时，在等待当前任务的响应返回之前，可以继续执行后续代码，即当前执行任务不会阻塞后续执行。</p>
								<blockquote>
								<p>异步编程，不同于同步编程的请求-响应模式，其是一种<a href="https://en.wikipedia.org/wiki/Event-driven_programming">事件驱动编程</a>，请求调用函数或方法后，无需立即等待响应，可以继续执行其他任务，而之前任务响应返回后可以通过状态、通知和回调来通知调用者。</p>
								</blockquote>
								<h4><span id="i-3">多线程</span></h4>
								<p>前面说明了异步编程能很好的解决同步编程阻塞的问题，那么实现异步的方式有哪些呢？通常实现异步方式是多线程，如C#, 即同时开启多个线程，不同操作能并行执行，如下图，耗时任务A执行的同时，在线程二中任务B也可以执行：</p>
								<p><img src="http://blog.codingplayboy.com/wp-content/uploads/2017/04/async-threads-flow.png" alt="多线程异步编程无阻塞流程"></p>
								<h4><span id="JavaScript">JavaScript单线程</span></h4>
								<p>JavaScript语言执行环境是单线程的，单线程在程序执行时，所走的程序路径按照连续顺序排下来，前面的必须处理好，后面的才会执行，而使用异步实现时，多个任务可以并发执行。那么JavaScript的异步编程如何实现呢，下一节将详细阐述其异步机制。</p>
								<h4><span id="i-4">并行与并发</span></h4>
								<p>前文提到多线程的任务可以并行执行，而JavaScript单线程异步编程可以实现多任务并发执行，这里有必要说明一下并行与并发的区别。</p>
								<ul>
								<li>并行，指同一时刻内多任务同时进行；</li>
								<li>并发，指在同一时间段内，多任务同时进行着，但是某一时刻，只有某一任务执行；</li>
								</ul>
								<p>通常所说的并发连接数，是指浏览器向服务器发起请求，建立TCP连接，每秒钟服务器建立的总连接数，而假如，服务器处10ms能处理一个连接，那么其并发连接数就是100。</p>
								<h2><span id="JavaScript-2">JavaScript异步机制</span></h2>
								<p>本节介绍JavaScript异步机制，首先来看一个例子：</p>
								<pre><code class="hljs javascript"><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i ++) {
								        setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
								            <span class="hljs-built_in">console</span>.log(i);
								        }, <span class="hljs-number">0</span>);
								    }
								    <span class="hljs-built_in">console</span>.log(i);
								    <span class="hljs-comment">//5 ; 5 ; 5 ; 5; 5</span>
								</code></pre>
								<p>应该明白最后输出的全是5：</p>
								<ol>
								<li>i在此处是for循环所在上下文环境的变量，有且只有一个i;</li>
								<li>循环结束时i==5;</li>
								<li>JavaScript单线程事件处理器在线程空闲前不会执行下一事件。</li>
								</ol>
								<p>如上面第三点所述，如果要真正理解以上例子中的setTimeout()，及JavaScript异步机制，需要理解JavaScript的事件循环和并发模型。</p>
								<h2><span id="Concurrency_model">并发模型（Concurrency model）</span></h2>
								<p>目前，我们已经知道，JavaScript执行异步任务时，不需要等待响应返回，可以继续执行其他任务，而在响应返回时，会得到通知，执行回调或事件处理程序。那么这一切具体是如何完成的，又以什么规则或顺序运作呢？接下来我们需要解答这个问题。</p>
								<p><strong>注：回调和事件处理程序本质上并无区别，只是在不同情况下，不同的叫法。</strong></p>
								<p>前文已经提到，JavaScript异步编程使得多个任务可以并发执行，而实现这一功能的基础是JavScript拥有一个基于事件循环的并发模型。</p>
								<h4><span id="i-5">堆栈与队列</span></h4>
								<p>介绍JavaScript并发模型之前，先简单介绍堆栈和队列的区别：</p>
								<ul>
								<li>堆（heap）：内存中某一未被阻止的区域，通常存储对象（引用类型）；</li>
								<li>栈（stack）：后进先出的顺序存储数据结构，通常存储函数参数和基本类型值变量（按值访问）；</li>
								<li>队列（queue）：先进先出顺序存储数据结构。</li>
								</ul>
								<h3><span id="Event_Loop">事件循环（Event Loop）</span></h3>
								<p>JavaScript引擎负责解析，执行JavaScript代码，但它并不能单独运行，通常都得有一个宿主环境，一般如浏览器或Node服务器，前文说到的单线程是指在这些宿主环境创建单一线程，提供一种机制，调用JavaScript引擎完成多个JavaScript代码块的调度，执行（是的，JavaScript代码都是按块执行的），这种机制就称为事件循环（Event Loop）。</p>
								<p><strong>注：这里的事件与DOM事件不要混淆，可以说这里的事件包括DOM事件，所有异步操作都是一个事件，诸如ajax请求就可以看作一个request请求事件。</strong></p>
								<p>JavaScript执行环境中存在的两个结构需要了解：</p>
								<ul>
								<li>消息队列(message queue)，也叫任务队列（task queue）：存储待处理消息及对应的回调函数或事件处理程序；</li>
								<li>执行栈(execution context stack)，也可以叫执行上下文栈：JavaScript执行栈，顾名思义，是由执行上下文组成，当函数调用时，创建并插入一个执行上下文，通常称为执行栈帧（frame），存储着函数参数和局部变量，当该函数执行结束时，弹出该执行栈帧；</li>
								</ul>
								<p><strong>注：关于全局代码，由于所有的代码都是在全局上下文执行，所以执行栈顶总是全局上下文就很容易理解，直到所有代码执行完毕，全局上下文退出执行栈，栈清空了；也即是全局上下文是第一个入栈，最后一个出栈。</strong></p>
								<h4><span id="i-6" tabindex="-1">任务</span></h4>
								<p>分析事件循环流程前，先阐述两个概念，有助于理解事件循环：同步任务和异步任务。</p>
								<p>任务很好理解，JavaScript代码执行就是在完成任务，所谓任务就是一个函数或一个代码块，通常以功能或目的划分，比如完成一次加法计算，完成一次ajax请求；很自然的就分为同步任务和异步任务。同步任务是连续的，阻塞的；而异步任务则是不连续，非阻塞的，包含异步事件及其回调，当我们谈及执行异步任务时，通常指执行其回调函数。</p>
								<h4><span id="i-7">事件循环流程</span></h4>
								<p>关于事件循环流程分解如下：</p>
								<ol>
								<li>宿主环境为JavaScript创建线程时，会创建堆(heap)和栈(stack)，堆内存储JavaScript对象，栈内存储执行上下文；</li>
								<li>栈内执行上下文的同步任务按序执行，执行完即退栈，而当异步任务执行时，该异步任务进入等待状态（不入栈），同时通知线程：当触发该事件时（或该异步操作响应返回时），需向消息队列插入一个事件消息；</li>
								<li>当事件触发或响应返回时，线程向消息队列插入该事件消息（包含事件及回调）；</li>
								<li>当栈内同步任务执行完毕后，线程从消息队列取出一个事件消息，其对应异步任务（函数）入栈，执行回调函数，如果未绑定回调，这个消息会被丢弃，执行完任务后退栈；</li>
								<li>当线程空闲（即执行栈清空）时继续拉取消息队列下一轮消息（next tick，事件循环流转一次称为一次tick）。</li>
								</ol>
								<p>使用代码可以描述如下：</p>
								<pre><code class="hljs cs"><br>    <span class="hljs-keyword">var</span> eventLoop = [];
								    <span class="hljs-keyword">var</span> <span class="hljs-keyword">event</span>;
								    <span class="hljs-keyword">var</span> i = eventLoop.length - <span class="hljs-number">1</span>; <span class="hljs-comment">// 后进先出</span>

								    <span class="hljs-keyword">while</span>(eventLoop[i]) {
								        <span class="hljs-keyword">event</span> = eventLoop[i--]; 
								        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">event</span>) { <span class="hljs-comment">// 事件回调存在</span>
								            <span class="hljs-keyword">event</span>();
								        }
								        <span class="hljs-comment">// 否则事件消息被丢弃</span>
								    }
								</code></pre>
								<p>这里注意的一点是等待下一个事件消息的过程是同步的。</p>
								<h5><span id="i-8">并发模型与事件循环</span></h5>
								<pre><code class="hljs javascript"><br>    <span class="hljs-keyword">var</span> ele = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'body'</span>);

								    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">clickCb</span>(<span class="hljs-params">event</span>) </span>{
								        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'clicked'</span>);
								    }
								    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bindEvent</span>(<span class="hljs-params">callback</span>) </span>{
								        ele.addEventListener(<span class="hljs-string">'click'</span>, callback);
								    }   

								    bindEvent(clickCb);
								</code></pre>
								<p>针对如上代码我们可以构建如下并发模型：</p>
								<p><img src="http://blog.codingplayboy.com/wp-content/uploads/2017/04/concurrency-model.png" alt="JavaScript并发模型"></p>
								<p>如上图，当执行栈同步代码块依次执行完直到遇见异步任务时，异步任务进入等待状态，通知线程，异步事件触发时，往消息队列插入一条事件消息；而当执行栈后续同步代码执行完后，读取消息队列，得到一条消息，然后将该消息对应的异步任务入栈，执行回调函数；一次事件循环就完成了，也即处理了一个异步任务。</p>
								<h4><span id="setTimeout82300">再谈setTimeout(…0)</span></h4>
								<p>了解了JavaScript事件循环后我们再看前文关于<code>setTimeout(...0)</code>的例子就比较清晰了：</p>
								<p><code>setTimeout(...0)</code>所表达的意思是：等待0秒后（这个时间由第二个参数值确定），往消息队列插入一条定时器事件消息，并将其第一个参数作为回调函数；而当执行栈内同步任务执行完毕时，线程从消息队列读取消息，将该异步任务入栈，执行；线程空闲时再次从消息队列读取消息。</p>
								<p>再看一个实例：</p>
								<pre><code class="hljs javascript"><br>    <span class="hljs-keyword">var</span> start = +<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();
								    <span class="hljs-keyword">var</span> arr = [];

								    setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{
								        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'time: '</span> + (<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>().getTime() - start));
								    },<span class="hljs-number">10</span>);

								    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>;i&lt;=<span class="hljs-number">1000000</span>;i++){
								        arr.push(i);
								    }
								</code></pre>
								<p>执行多次输出如下：</p>
								<p><img src="http://blog.codingplayboy.com/wp-content/uploads/2017/04/settimeout0.png" alt="setTimeout(...0)"></p>
								<p>在<code>setTimeout</code>异步回调函数里我们输出了异步任务注册到执行的时间，发现并不等于我们指定的时间，而且两次时间间隔也都不同，考虑以下两点：</p>
								<ul>
								<li>在读取消息队列的消息时，得等同步任务完成，这个是需要耗费时间的；</li>
								<li>消息队列先进先出原则，读取此异步事件消息之前，可能还存在其他消息，执行也需要耗时；</li>
								</ul>
								<p>所以异步执行时间不精确是必然的，所以我们有必要明白无论是同步任务还是异步任务，都不应该耗时太长，当一个消息耗时太长时，应该尽可能的将其分割成多个消息。</p>
								<h4><span id="Web_Workers">Web Workers</span></h4>
								<p>每个Web Worker或一个跨域的iframe都有各自的堆栈和消息队列，这些不同的文档只能通过postMessage方法进行通信，当一方监听了message事件后，另一方才能通过该方法向其发送消息，这个message事件也是异步的，当一方接收到另一方通过postMessage方法发送来的消息后，会向自己的消息队列插入一条消息，而后续的并发流程依然如上文所述。</p>
								<h2><span id="JavaScript-3" tabindex="-1">JavaScript异步实现</span></h2>
								<p>关于JavaScript的异步实现，以前有：回调函数，发布订阅模式，Promise三类，而在ES6中提出了生成器（Generator）方式实现。</p>								
								<div style="clear:both; margin-top:5px; margin-bottom:5px;"></div><div style="float:left">
								<!-- JiaThis Button BEGIN -->
								<div class="jiathis_style_24x24">
									<span class="jiathis_txt">分享到：</span>
									<a class="jiathis_button_qzone"></a>
									<a class="jiathis_button_tsina"></a>
									<a class="jiathis_button_tqq"></a>
									<a class="jiathis_button_weixin"></a>
									<a class="jiathis_button_renren"></a>
									<a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jiathis_separator jtico jtico_jiathis" target="_blank">更多</a>
								</div>
								<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js" charset="utf-8"></script><!-- <script type="text/javascript" src="http://v3.jiathis.com/code/plugin.client.js" charset="utf-8"></script> -->
								<!-- JiaThis Button END -->
								</div><div style="clear:both; margin-top:5px; margin-bottom:5px;"></div></div>
					</article>
			    </div>
			    <div id="cnt4">
					<h2 class="title">H5缓存机制解析</h2>
			    </div>
			    <div id="cnt5">

			    </div>
			    <div id="cnt6">

			    </div>
			</div>
		</div>

	</div>
</body>
</html>
<script type="text/javascript">
function dataformat(){
  var time = new Date();
  var week=["星期日","星期一","星期二","星期三","星期四","星期五","星期六"];
  var num=time.getDay();//返回值存储在变量num中
  var y = time.getFullYear();
  var m = time.getMonth()+1 < 10 ? ('0' + (time.getMonth()+1)) : (time.getMonth()+1);
  var d = time.getDate() < 10 ? '0' + time.getDate() : time.getDate();
  var h = time.getHours() < 10 ? '0' + time.getHours() : time.getHours();
  var mm = time.getMinutes() <10 ? '0' + time.getMinutes() : time.getMinutes();
  var s = time.getSeconds() <10 ? '0' + time.getSeconds() : time.getSeconds();
  return week[num] +'&nbsp&nbsp&nbsp&nbsp'+y+'-'+m+'-'+d+'  '+h+':'+mm;
  // datestr = week[num] +'&nbsp&nbsp&nbsp&nbsp'+y+'-'+m+'-'+d+'  '+h+':'+mm+':'+s; 
}
var datestr = dataformat();
$('#header .time').html(datestr); 
setInterval(function(){
  datestr = dataformat();
  $('#header .time').html(datestr);
},60000);
</script>